"""
Service Public Engagement pour AGRIFRIKA Dashboard
Récupération des données d'engagement depuis Google Sheets
"""

import logging
from typing import Optional, Dict, Any
from datetime import datetime
from google.oauth2.service_account import Credentials
from googleapiclient.discovery import build
from app.core.config import settings
from app.services.kpi_calculator import PublicEngagementCalculator

logger = logging.getLogger(__name__)

class PublicEngagementService:
    """Service pour récupérer les données d'engagement public depuis Google Sheets"""
    
    def __init__(self):
        self.service = None
        self.calculator = PublicEngagementCalculator()
        self._initialize_api()
    
    def _initialize_api(self) -> None:
        """Initialise la connexion à l'API Google Sheets"""
        try:
            credentials = Credentials.from_service_account_file(
                settings.sheets_credentials_full_path,
                scopes=['https://www.googleapis.com/auth/spreadsheets.readonly']
            )
            self.service = build('sheets', 'v4', credentials=credentials)
            logger.info("✅ Google Sheets API initialisée pour Public Engagement")
        except Exception as e:
            logger.error(f"❌ Erreur initialisation Google Sheets API: {e}")
    
    async def get_engagement_data(self) -> Optional[Dict[str, Any]]:
        """Récupère les données d'engagement depuis Google Sheets"""
        if not self.service:
            logger.warning("Google Sheets API non initialisée")
            return None
        
        try:
            # Récupération des données d'engagement
            result = self.service.spreadsheets().values().get(
                spreadsheetId=settings.PUBLIC_ENGAGEMENT_SHEET_ID,
                range=settings.ENGAGEMENT_METRICS_RANGE
            ).execute()
            
            values = result.get('values', [])
            
            if not values:
                logger.warning("Aucune donnée trouvée dans le sheet d'engagement")
                return None
            
            # Chercher la ligne avec Status="Latest"
            data_row = None
            for row in values:
                if len(row) >= 15:  # Vérifier qu'on a toutes les colonnes incluant Status (O)
                    status = row[14] if len(row) > 14 else ""  # Colonne O (15ème colonne)
                    if status.lower() == "latest":
                        data_row = row
                        break
            
            # Si pas de "Latest" trouvé, prendre la première ligne comme fallback
            if not data_row and values:
                data_row = values[0]
                logger.warning("Aucune ligne avec Status='Latest' trouvée, utilisation de la première ligne")
            
            if not data_row or len(data_row) < 13:  # Vérifier qu'on a au moins les colonnes de base
                logger.warning("Données incomplètes dans le sheet d'engagement")
                return None
            
            # Mapping des colonnes selon la structure du sheet
            # A: Date, B: Semaine, C: Vues, D: Likes, E: Partages, F: Commentaires, 
            # G: Nouveaux_abonnés, H: Téléchargement_app, I: Visites_uniques, 
            # J: Mention_médias, K: Newsletter, L: Événement_50+, M: Recherches, N: Impressions_LinkedIn, O: Status
            
            engagement_data = {
                "date": data_row[0] if len(data_row) > 0 else "",
                "semaine": data_row[1] if len(data_row) > 1 else "",
                "vues": self._safe_int(data_row[2]) if len(data_row) > 2 else 0,
                "likes_reactions": self._safe_int(data_row[3]) if len(data_row) > 3 else 0,
                "partages": self._safe_int(data_row[4]) if len(data_row) > 4 else 0,
                "commentaires": self._safe_int(data_row[5]) if len(data_row) > 5 else 0,
                "nouveaux_abonnes": self._safe_int(data_row[6]) if len(data_row) > 6 else 0,
                "telechargement_app": self._safe_int(data_row[7]) if len(data_row) > 7 else 0,
                "visites_uniques_site": self._safe_int(data_row[8]) if len(data_row) > 8 else 0,
                "mention_medias": self._safe_int(data_row[9]) if len(data_row) > 9 else 0,
                "newsletter": self._safe_int(data_row[10]) if len(data_row) > 10 else 0,
                "evenement_50plus_participants": self._safe_int(data_row[11]) if len(data_row) > 11 else 0,
                "apparition_recherches": self._safe_int(data_row[12]) if len(data_row) > 12 else 0,
                "impressions_linkedin": self._safe_int(data_row[13]) if len(data_row) > 13 else 0,
                "status": data_row[14] if len(data_row) > 14 else ""
            }
            
            logger.info(f"✅ Données d'engagement récupérées: {engagement_data}")
            return engagement_data
            
        except Exception as e:
            logger.error(f"Erreur récupération données d'engagement: {e}")
            return None
    
    async def get_latest_video(self) -> Optional[Dict[str, Any]]:
        """Récupère les données de la dernière vidéo postée"""
        if not self.service:
            logger.warning("Google Sheets API non initialisée")
            return None
        
        try:
            # Récupération des données vidéos
            result = self.service.spreadsheets().values().get(
                spreadsheetId=settings.PUBLIC_ENGAGEMENT_SHEET_ID,
                range=settings.VIDEOS_RANGE
            ).execute()
            
            values = result.get('values', [])
            
            if not values:
                logger.warning("Aucune donnée vidéo trouvée")
                return None
            
            # Chercher la vidéo avec le status "latest" ou prendre la première
            latest_video = None
            for row in values:
                if len(row) >= 9:  # Vérifier qu'on a toutes les colonnes
                    status = row[8] if len(row) > 8 else ""
                    if status.lower() == "latest":
                        latest_video = row
                        break
            
            # Si pas de "latest" trouvé, prendre la première ligne
            if not latest_video and values:
                latest_video = values[0]
            
            if not latest_video or len(latest_video) < 8:
                logger.warning("Données vidéo incomplètes")
                return None
            
            # Mapping des colonnes vidéo
            # A: Date_publication, B: Plateforme, C: URL, D: Titre, 
            # E: Vues, F: Likes, G: Partages, H: Commentaires, I: Status
            
            video_data = {
                "date_publication": latest_video[0] if len(latest_video) > 0 else "",
                "plateforme": latest_video[1] if len(latest_video) > 1 else "",
                "url": latest_video[2] if len(latest_video) > 2 else "",
                "titre": latest_video[3] if len(latest_video) > 3 else "",
                "vues": self._safe_int(latest_video[4]) if len(latest_video) > 4 else 0,
                "likes": self._safe_int(latest_video[5]) if len(latest_video) > 5 else 0,
                "partages": self._safe_int(latest_video[6]) if len(latest_video) > 6 else 0,
                "commentaires": self._safe_int(latest_video[7]) if len(latest_video) > 7 else 0,
                "status": latest_video[8] if len(latest_video) > 8 else "active"
            }
            
            logger.info(f"✅ Données vidéo récupérées: {video_data}")
            return video_data
            
        except Exception as e:
            logger.error(f"Erreur récupération données vidéo: {e}")
            return None
    
    async def get_top_content(self) -> Optional[list]:
        """Récupère les 2 contenus avec le plus de vues depuis le Google Sheet"""
        if not self.service:
            logger.warning("Google Sheets API non initialisée")
            return None
        
        try:
            # Récupération des données de la feuille top-content
            result = self.service.spreadsheets().values().get(
                spreadsheetId=settings.PUBLIC_ENGAGEMENT_SHEET_ID,
                range='top-content!A:D'  # Colonnes: Plateforme, Titre, URL, Vues
            ).execute()
            
            values = result.get('values', [])
            
            if not values or len(values) <= 1:  # Pas de données ou seulement l'en-tête
                logger.warning("Aucune donnée trouvée dans la feuille top-content")
                return []
            
            # Ignorer l'en-tête et traiter les données
            data_rows = values[1:] if values else []
            
            # Convertir en objets avec tri par vues
            content_items = []
            for row in data_rows:
                if len(row) >= 4:  # Vérifier qu'on a toutes les colonnes
                    try:
                        vues = self._safe_int(row[3])  # Colonne D: Vues
                        if vues > 0:  # Seulement les contenus avec des vues
                            content_items.append({
                                "platform": row[0] if len(row) > 0 else "",  # Colonne A: Plateforme
                                "title": row[1] if len(row) > 1 else "",     # Colonne B: Titre
                                "url": row[2] if len(row) > 2 else "",       # Colonne C: URL
                                "vues": vues
                            })
                    except Exception as e:
                        logger.warning(f"Erreur traitement ligne top-content: {e}")
                        continue
            
            # Trier par nombre de vues (décroissant) et prendre les 2 premiers
            content_items.sort(key=lambda x: x["vues"], reverse=True)
            top_2_content = content_items[:2]
            
            logger.info(f"✅ Top 2 contenus récupérés: {top_2_content}")
            return top_2_content
            
        except Exception as e:
            logger.error(f"Erreur récupération top content: {e}")
            return []

    async def get_monthly_trend(self) -> Optional[list]:
        """Récupère les données de tendance mensuelle depuis le Google Sheet"""
        if not self.service:
            logger.warning("Google Sheets API non initialisée")
            return None
        
        try:
            # Récupération des données de tendance (derniers 3 mois)
            result = self.service.spreadsheets().values().get(
                spreadsheetId=settings.PUBLIC_ENGAGEMENT_SHEET_ID,
                range='tendance!A:B'  # Colonnes: Mois, Score
            ).execute()
            
            values = result.get('values', [])
            
            if not values or len(values) <= 1:  # Pas de données ou seulement l'en-tête
                logger.warning("Aucune donnée trouvée dans la feuille tendance")
                return []
            
            # Ignorer l'en-tête et traiter les données
            data_rows = values[1:] if values else []
            
            # Convertir en objets
            trend_data = []
            for row in data_rows:
                if len(row) >= 2:  # Vérifier qu'on a toutes les colonnes
                    try:
                        score = self._safe_int(row[1])  # Colonne B: Score
                        trend_data.append({
                            "month": row[0] if len(row) > 0 else "",  # Colonne A: Mois
                            "score": score
                        })
                    except Exception as e:
                        logger.warning(f"Erreur traitement ligne tendance: {e}")
                        continue
            
            # Prendre les 3 derniers mois
            trend_data = trend_data[-3:] if len(trend_data) >= 3 else trend_data
            
            logger.info(f"✅ Données de tendance récupérées: {trend_data}")
            return trend_data
            
        except Exception as e:
            logger.error(f"Erreur récupération tendance: {e}")
            return []

    async def calculate_engagement_score(self) -> Optional[Dict[str, Any]]:
        """Calcule le score d'engagement basé sur les données Google Sheets"""
        engagement_data = await self.get_engagement_data()
        top_content = await self.get_top_content()
        monthly_trend = await self.get_monthly_trend()
        
        if not engagement_data:
            return None
        
        # Utiliser le calculateur pour obtenir le score
        score_result = self.calculator.calculate_score(engagement_data)
        
        # Ajouter les données réelles
        score_result["top_content"] = top_content or []
        score_result["monthly_trend"] = monthly_trend or []
        score_result["last_updated"] = datetime.now().isoformat()
        score_result["raw_data"] = engagement_data
        
        return score_result
    
    def _safe_int(self, value: str) -> int:
        """Convertit une valeur en entier de manière sécurisée"""
        if not value or value == "" or value == "-":
            return 0
        
        try:
            # Nettoyer la valeur (supprimer les espaces, virgules, etc.)
            cleaned_value = str(value).replace(" ", "").replace(",", "")
            return int(float(cleaned_value))
        except (ValueError, TypeError):
            logger.warning(f"Impossible de convertir '{value}' en entier")
            return 0
    
    def health_check(self) -> bool:
        """Vérifie la santé de la connexion Google Sheets pour Public Engagement"""
        try:
            if not self.service:
                return False
            
            # Test simple de lecture
            result = self.service.spreadsheets().values().get(
                spreadsheetId=settings.PUBLIC_ENGAGEMENT_SHEET_ID,
                range='A1:B2'
            ).execute()
            
            return 'values' in result
            
        except Exception as e:
            logger.error(f"Public Engagement Google Sheets health check failed: {e}")
            return False